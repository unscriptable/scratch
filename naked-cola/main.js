define({

	/**
	 * This is an attempt to do data binding without any cola adapters or hub.
	 * When we first started cola, we didn't have nearly as many tools in
	 * wire, so it simply wasn't possible.  Now, however, we've got lots
	 * more, specifically wire/dom and wire/functional.
	 *
	 * Conclusion: it's almost possible now.  We just need a few more wire
	 * plugins and cola functions.
	 */

	/**
	 * Note: I didn't want to have to keep a separate copy of the data items
	 * "near the nodes".  This poses issues for comparators and identifiers.
	 *
	 * We have the following options:
	 * 1. keep a copy of the original items to use comparators and identifiers
	 *    that are provided from a data source
	 * 2. have positional data provided with the data (like dojo Observable)
	 * 3. use dom-specific comparators and identifiers
	 *
	 * I chose #3.
	 */

	mainView: {
		render: {
			template: '<ul></ul>'
		},
		insert: { at: document.body }
	},

	itemView: {
		render: {
			template: '<li><input type="checkbox"/><span></span></li>'
		}
	},

	controller: {
		add: { compose: 'createNode|insertNode' },
		update: { compose: 'findNode|updateNode|insertNode' }, // not quite right
		remove: { compose: 'findNode|removeNode' }
	},

	// It'd be convenient to put identifier and comparator meta-info
	// in here, and let a wire/cola plugin create the dom accessors
	// at the bottom of this file.
	nodeMap: {
		literal: [
			{ prop: 'id', attr: 'data-cola-id' /*, identifier: true */ },
			{ prop: 'complete', selector: 'input', attr: 'checked' /*, sort: +1*/ },
			{ prop: 'description', selector: 'span', attr: 'text' /*, sort: +2*/ }
		]
	},

	createNode: {
		create: 'cola/dom/objectToDom',
		args: {
			mappings: { $ref: 'nodeMap' },
			templateNode: { $ref: 'itemView' },
			nodeSelector: { $ref: 'dom!' }
		}
	},

	insertNode: {
		create: 'cola/dom/insertNode',
		args: {
			rootNode: { $ref: 'mainView' },
			nodeSelector: { $ref: 'dom!' },
			selector: 'li',
			comparator: { $ref: 'compareNodes' }
		}
	},

	// this could get auto-generated by wire/cola or cola/dom/* using nodeMap
	findNode: {
		create: function (config) {
			return function (item) {
				var selector = '[data-cola-id="' + item['id'] + '"]';
				return config.qs(selector, config.rootNode);
			};
		},
		args: {
			qs: { $ref: 'dom.first!' },
			rootNode: { $ref: 'mainView' }
		}
	},

	updateNode: {

	},

	// this could go into wire/dom somewhere
	removeNode: function (node) {
		if (node.parentNode) node.parentNode.removeChild(node); return node
	},

	compareNodes: {
		create: 'cola/comparator/compose',
		args: [[
			{ $ref: 'reverseChecked' },
			{ $ref: 'compareDescription' }
		]]
	},

	reverseChecked: {
		create: 'cola/comparator/reverse',
		args: { $ref: 'compareChecked' }
	},

	compareChecked: {
		// I needed a function to extract a property from a dom node, but
		// it seems that a function that reduces a "thing" to a primitive
		// type is a rather generic operation.  Thus, "byReducer".
		// Are "bySerializer" or "byFunction" better names?
		create: 'cola/comparator/byReducer',
		args: { $ref: 'getChecked' }
	},

	compareDescription: {
		create: 'cola/comparator/byReducer',
		args: { $ref: 'getDescription' }
	},

	getChecked: {
		// dom.prop uses a selector to find a node and then gets a property
		// from it. e.g. { $ref: 'dom.prop!input.cb[checked]' }
		// Alternate solutions:
		// { $ref: 'dom.prop!input.cb', prop: 'checked' }
		// { $ref: 'dom.first!input.cb', prop: 'checked' }
		// curry binds-in some arguments and returns a function
		curry: { $ref: 'dom.prop!' },
		args: [ 'input', 'checked' ]
	},

	getDescription: {
		curry: { $ref: 'dom.prop!' },
		args: [ 'span', 'text' ]
	},

	getId: {
		curry: { $ref: 'dom.prop!' },
		args: [ 'li', 'data-cola-id' ]
	},

	plugins: [
		//{ module: 'wire/debug' }
		{ module: 'wire/dom' },
		{ module: 'wire/dom/render' },
		{ module: 'wire/functional' }
	]
});